struct ray{
    float3 origin;
    float3 direction;
    float t;
};

struct sphere{
    float3 position;
    float radius;
    int material_index;
};

struct sphere_intersection{
    bool intersect;
    float distance;
};

struct material{
    float3 albedo;
    float reflectance;
};

struct camera{
    float3 pos;
    float3 dir;
};

#define EPSILON 0.0001f
#define MAX_DEPTH 5

#define TOTAL_SPHERES 3
struct sphere spheres[TOTAL_SPHERES] = {};

#define TOTAL_MATERIALS 3
struct material materials[TOTAL_MATERIALS] = {};

struct sphere_intersection intersect_sphere(struct sphere s, struct ray r){
    struct sphere_intersection intersection;
    intersection.intersect = false;
    intersection.distance = -INFINITY;

    float3 center = s.position - r.origin;
    float distance = dot(center, r.direction);
    float3 q = center - distance * r.direction;
    float p2 = dot(q, q);
    float radius2 = s.radius * s.radius;

    if (p2 > radius2) {
        return intersection;
    }

    float t1 = distance - sqrt(radius2 - p2);
    float t2 = distance + sqrt(radius2 - p2);

    if (t1 > 0.0 && t1 < r.t) {
        intersection.intersect = true;
        intersection.distance = t1;
    } else if (t2 > 0.0 && t2 < r.t) {
        intersection.intersect = true;
        intersection.distance = t2;
    }

    return intersection;
}

float3 get_ray_pos(struct ray r){
    return r.origin + r.t * r.direction;
}

float2 get_sphere_uv_coordinates(float3 point){
    float theta = acos(-point.y);
    float phi = atan2(point.z, point.x) + M_PI;
    return (float2)(phi/(M_PI*2.0), theta / M_PI);
}

float4 get_sky_color(float3 direction, image2d_t sky){
     const sampler_t samplerA = CLK_NORMALIZED_COORDS_TRUE |
                                CLK_ADDRESS_NONE |
                                CLK_FILTER_NEAREST;
    return read_imagef(sky, samplerA, get_sphere_uv_coordinates(direction));
}

float4 reflect(float3 hit, float3 normal, struct ray in_ray, int depth, image2d_t sky);
float4 refract(float3 hit, float3 normal, struct ray in_ray, float refractive_index_div, int depth, image2d_t sky);

float4 trace(struct ray r, int depth, image2d_t sky){
    bool did_intersect = false;

    if (depth >= MAX_DEPTH){
        return (float4)(1.0,0.0,1.0,0.0);
    }

    // Find intersection
    float last_distance = INFINITY;
    struct sphere_intersection result;
    int object_index = -1;
    for (int i = 0; i < TOTAL_SPHERES; i++){
        struct sphere_intersection current_result = intersect_sphere(spheres[i], r);
        float distance = current_result.distance;
        if (current_result.intersect && distance >= 0.0 && distance < last_distance){
            last_distance = distance;
            object_index = i;
            did_intersect = true;
            result = current_result;
        }
    }

    // Apply shading
    if (did_intersect){
        r.t = result.distance;
        float3 ray_pos = get_ray_pos(r);
        float3 normal =  normalize(ray_pos - spheres[object_index].position);

        struct material mat = materials[spheres[object_index].material_index];
        if (spheres[object_index].material_index == 1){

            float n = 1.0f;
            float nt = 1.52f;

            if(dot(r.direction, normal)>0){
                //n = 1.f / n;
                //nt = 1.f / nt;
                n = 1.52f;
                nt = 1.0f;
                normal = -normal;
            }

            float incomming_angle = dot(normal, r.direction);
            float div_refractive_index = n/nt;
            float out_angle = sqrt(1.0f - pow(div_refractive_index * incomming_angle,2.0f));

            // Schlick's approximation
            float3 ray_dir = r.direction;
            if(dot(normal, ray_dir) < 0.0f){
                ray_dir = -ray_dir;
            }
            float reflectance = ((n - nt) / (n + nt)) * ((n - nt) / (n + nt));
            float fresnel = reflectance + (1.f - reflectance) * (pow(1.f - dot(normal, ray_dir), 5.0f));;

            return refract(get_ray_pos(r), normal, r, div_refractive_index, ++depth, sky) * (1.0f - fresnel) + reflect(get_ray_pos(r), normal, r, ++depth, sky) * (fresnel);
        }

        float ndl = -dot(normal, r.direction);
        float4 color = (float4)(mat.albedo * ndl, 0.0);
        float4 reflection = reflect(get_ray_pos(r), normal, r, ++depth, sky);
        return color * (1.0f - mat.reflectance) + reflection * mat.reflectance;

        //return (float4)(0.5 * normal.x + 1, 0.5 * normal.y + 1, 0.5 * normal.z + 1, 0.0);
        //return color;
        //return (float4)(distance,distance,distance,0.0);
        //return (float4)(1.0,0.0,0.0,0.0);
    }
    

    if (!did_intersect){
        return get_sky_color(r.direction, sky);
    }
}

float4 reflect(float3 hit, float3 normal, struct ray in_ray, int depth, image2d_t sky){
    struct ray out_ray;
    float3 reflect_dir = in_ray.direction - 2.0f * dot(in_ray.direction, normal) * normal;

    out_ray.origin = hit + reflect_dir * EPSILON;
    out_ray.direction = reflect_dir;
    out_ray.t = INFINITY;
    
    return trace(out_ray, depth, sky);
}

float4 refract(float3 hit, float3 normal, struct ray in_ray, float refractive_index_div, int depth, image2d_t sky){
    float incomming_angle = dot(normal, in_ray.direction);
    float k = 1.0f - (refractive_index_div*refractive_index_div) * (1.0f - (incomming_angle*incomming_angle));
    if (k >= 0.0f){
        struct ray out_ray;

        float3 out_dir = refractive_index_div * in_ray.direction + normal * (refractive_index_div*incomming_angle - sqrt(k));
        out_ray.origin = hit * out_dir * EPSILON;
        out_ray.direction = out_dir;
        out_ray.t = INFINITY;

        return trace(out_ray, depth, sky);
        //return (float4)(1.0f, 1.0f, 1.0f, 1.0f);
    }
    return (float4)(0.0f, 0.0f, 0.0f, 0.0f);
}

float3 transform_vector3_matrix(float16 matrix, float3 in){
    float4 out;
    float4 x_axis = matrix.s0123;
    float4 y_axis = matrix.s4567;
    float4 z_axis = matrix.s89AB;

    out = x_axis * in.x;
    out += y_axis * in.y;
    out += z_axis * in.z;

    return out.xyz;
}

float4 first_hit(float2 coord, float aspect_ratio, float time, float16 camera_matrix, image2d_t sky){
    
    float3 cam_pos = camera_matrix.sCDE;
    //float3 view_dir = {0.0,sin(time * 0.5) * 0.1,1.0};
    float3 view_dir = {0.0, 0.0, 1.0};

    float3 test = {0.0,0.0,1.0};
    float fov = 1.0;
    float3 center = cam_pos + fov * view_dir;

    float3 p0 = center + (float3)(-1.0, -1.0, 0.0);
    float3 p1 = center + (float3)(1.0, -1.0, 0.0);
    float3 p2 = center + (float3)(-1.0, 1.0, 0.0);

    // Apply Camera Matrix
    cam_pos = transform_vector3_matrix(camera_matrix, cam_pos);
    p0 = transform_vector3_matrix(camera_matrix, p0);
    p1 = transform_vector3_matrix(camera_matrix, p1);
    p2 = transform_vector3_matrix(camera_matrix, p2);

    float3 screen_pos = p0 + (float)(coord.x) * (p1 - p0) * aspect_ratio + (float)(coord.y) * (p2 - p0);

    struct ray r; 
    r.origin = cam_pos;
    r.direction = normalize(screen_pos - cam_pos);
    r.t = INFINITY;

    materials[0].albedo = (float3)(1.0, 1.0, 1.0);
    materials[0].reflectance = 0.995f;

    materials[1].albedo = (float3)(0.0, 1.0, 0.0);
    materials[1].reflectance = 0.3f;

    materials[2].albedo = (float3)(0.0, 0.0, 1.0);
    materials[2].reflectance = 0.3f;

    spheres[0].position = (float3)(cos(time) * 4.0, sin(time) * 4.0, 5.0 + cos(time) * 3.0);
    spheres[0].radius = 2.0;
    spheres[0].material_index = 0;

    spheres[1].position = (float3)(cos(time + 2.0) * 4.0, sin(time + 2.0) * 4.0, 5.0 + cos(time + 2.0) * 3.0);
    spheres[1].radius = 2.0;
    spheres[1].material_index = 1;

    spheres[2].position = (float3)(cos(time + 4.0) * 4.0, sin(time + 4.0) * 4.0, 5.0 + cos(time + 4.0) * 3.0);
    spheres[2].radius = 2.0;
    spheres[2].material_index = 2;

    return trace(r, 0, sky);
}

__kernel void main(
            read_only float time,
            __global float16* camera_matrix,
            read_only image2d_t sky_image,
            write_only image2d_t dst_image)
{
    int2 coord = (int2)(get_global_id(0), get_global_id(1));

    int max_x = get_global_size(0) - 1; 
    int max_y = get_global_size(1) - 1;

    float2 uv = (float2)((float)coord.x / (float)(max_x),(float)(coord.y) / (float)(max_y));

    float4 pixel = first_hit(uv, (float)max_x / (float)max_y, time, *camera_matrix, sky_image);
    // NOTE: Sanity Check.
    //float4 pixel = (float4)(sin(time), cos(time), 0.0, 1.0);
    const sampler_t samplerA = CLK_NORMALIZED_COORDS_TRUE |
                            CLK_ADDRESS_CLAMP |
                           CLK_FILTER_NEAREST;
    //float4 pixel = read_imagef(sky_image, samplerA, uv);

    // HDR Tonemapping
    // Exposure
    float exposure = 8.0f;
    // Apply exposure adjustment
    float4 linear_value = pixel * exposure;
    // Apply tone mapping: Simple linear scaling to [0, 1]
    pixel = linear_value / (1.0f + linear_value);

    write_imagef(dst_image, coord, pixel);
}