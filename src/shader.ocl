struct ray{
    float3 origin;
    float3 direction;
    float t;
};

struct sphere{
    float3 position;
    float radius;
    float3 color;
};

struct sphere_intersection{
    bool intersect;
    float distance;
};

#define EPSILON FLT_EPSILON
#define MAX_DEPTH 100

#define TOTAL_SPHERES 3
struct sphere spheres[TOTAL_SPHERES] = {};

struct sphere_intersection intersect_sphere(struct sphere s, struct ray r){
    struct sphere_intersection intersection;
    intersection.intersect = false;
    intersection.distance = -INFINITY;

    float3 center = s.position - r.origin;
    float distance = dot(center, r.direction);
    float3 q = center - distance * r.direction;
    float p2 = dot(q, q);
    float radius2 = s.radius * s.radius;

    if (p2 > radius2) {
        return intersection;
    }

    float t1 = distance - sqrt(radius2 - p2);
    float t2 = distance + sqrt(radius2 - p2);

    if (t1 > 0.0 && t1 < r.t) {
        intersection.intersect = true;
        intersection.distance = t1;
    } else if (t2 > 0.0 && t2 < r.t) {
        intersection.intersect = true;
        intersection.distance = t2;
    }

    return intersection;
}

float3 get_ray_pos(struct ray r){
    return r.origin + r.t * r.direction;
}

struct ray reflect(float3 hit, float3 normal, struct ray in_ray){
    struct ray out_ray;
    float3 reflect_dir = in_ray.direction - 2.0f * dot(in_ray.direction, normal) * normal;

    out_ray.origin = hit + reflect_dir * 0.01f;
    out_ray.direction = reflect_dir;
    out_ray.t = INFINITY;
    
    return out_ray;
}

float4 trace(struct ray r, int depth){
    bool did_intersect = false;

    if (MAX_DEPTH > 100){
        return (float4)(0.0,0.0,0.0,0.0);
    }

    for (int i = 0; i < TOTAL_SPHERES; i++){
        struct sphere_intersection result = intersect_sphere(spheres[i], r);
        if (result.intersect){
            did_intersect = true;
            r.t = result.distance;
            float3 ray_pos = get_ray_pos(r);
            float3 normal =  normalize(ray_pos - spheres[i].position);
            float distance = 1.0 / r.t;

            float ndl = -dot(normal, r.direction);
            float4 color =  (float4)(spheres[i].color * ndl, 0.0);
            float4 reflection = trace(reflect(get_ray_pos(r), normal, r), depth + 1);
            return color * 0.7f + reflection * 0.3f;

            //return (float4)(0.5 * normal.x + 1, 0.5 * normal.y + 1, 0.5 * normal.z + 1, 0.0);
            //return color;
            //return (float4)(distance,distance,distance,0.0);
            //return (float4)(1.0,0.0,0.0,0.0);
        }
    }

    if (!did_intersect){
        return (float4)(0.0,0.0,0.0,0.0);
    }
}

float4 first_hit(float2 coord, float aspect_ratio, float time){
    float3 cam_pos = {0.0,0.0,-2.0};
    float3 view_dir = {0.0,0.0,1.0};
    float3 test = {0.0,0.0,1.0};
    float fov = 1.0;
    float3 center = cam_pos + fov * view_dir;

    float3 p0 = center + (float3)(-1.0, -1.0, 0.0);
    float3 p1 = center + (float3)(1.0, -1.0, 0.0);
    float3 p2 = center + (float3)(-1.0, 1.0, 0.0);

    float3 screen_pos = p0 + (float)(coord.x) * (p1 - p0) * aspect_ratio + (float)(coord.y) * (p2 - p0);

    struct ray r; 
    r.origin = cam_pos;
    r.direction = normalize(screen_pos - cam_pos);
    r.t = INFINITY;

    spheres[0].position = (float3)(cos(time) * 4.0, sin(time) * 4.0, 5.0 + cos(time) * 3.0);
    spheres[0].radius = 2.0;
    spheres[0].color = (float3)(1.0, 0.0, 0.0);

    spheres[1].position = (float3)(cos(time + 2.0) * 4.0, sin(time + 2.0) * 4.0, 5.0 + cos(time + 2.0) * 3.0);
    spheres[1].radius = 2.0;
    spheres[1].color = (float3)(0.0, 1.0, 0.0);

    spheres[2].position = (float3)(cos(time + 4.0) * 4.0, sin(time + 4.0) * 4.0, 5.0 + cos(time + 4.0) * 3.0);
    spheres[2].radius = 2.0;
    spheres[2].color = (float3)(0.0, 0.0, 1.0);

    return trace(r, 0);
}

__kernel void main(
            read_only float time,
            write_only image2d_t dst_image)
{
    int2 coord = (int2)(get_global_id(0), get_global_id(1));

    int max_x = get_global_size(0) - 1; 
    int max_y = get_global_size(1) - 1;

    float2 uv = (float2)((float)coord.x / (float)(max_x),(float)(coord.y) / (float)(max_y));

    float4 pixel = first_hit(uv, (float)max_x / (float)max_y, time);
    // NOTE: Sanity Check.
    //float4 pixel = (float4)(sin(time), cos(time), 0.0, 1.0);

    write_imagef(dst_image, coord, pixel);
}